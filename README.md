# protoc-pojo-gen

This is a plugin built with [protoc-plugin-common](https://github.com/turbonomic/protoc-plugin-common) to generate POJOs capable of building and representing the same objects as generated by the Java protobuf language bindings, but with a lower memory footprint (for certain access patterns, memory usage may decrease by over 50% as compared to standard protobuf builders).

## Usage
To use the plugin:

Since the plugin is not currently in Maven Central, you'll need to clone this repository and build (using ```mvn```) first.

Then configure your build to use the plugin. This is what that might look like with protobuf-maven-plugin:

```
<plugin>
  <groupId>org.xolstice.maven.plugins</groupId>
  <artifactId>protobuf-maven-plugin</artifactId>
  <version>${protobuf.maven.plugin.version}</version>
  <configuration>
    <protoSourceRoot>src/main/protobuf</protoSourceRoot>
    <protoTestSourceRoot>src/test/protobuf</protoTestSourceRoot>
    <!-- os.detected.classifier provided by os-maven-plugin -->
    <protocArtifact>com.google.protobuf:protoc:${protobuf.version}:exe:${os.detected.classifier}</protocArtifact>
    <!-- grpc-java generates gRPC client and server stubs for protobuf-defined services -->
    <pluginId>grpc-java</pluginId>
    <pluginArtifact>io.grpc:protoc-gen-grpc-java:${grpc.version}:exe:${os.detected.classifier}</pluginArtifact>
    <protocPlugins>
      <protocPlugin>
        <id>spring-rest</id>
        <groupId>com.turbonomic</groupId>
        <artifactId>protoc-pojo-gen-plugin</artifactId>
        <version>HEAD-SNAPSHOT</version>
        <mainClass>com.turbonomic.protoc.pojo.gen.Main</mainClass>
      </protocPlugin>
    </protocPlugins>
  </configuration>
  <executions>
    <execution>
      <goals>
        <goal>compile</goal>
        <goal>compile-custom</goal>
        <goal>test-compile</goal>
        <goal>test-compile-custom</goal>
      </goals>
    </execution>
  </executions>
</plugin>
```

Rebuild, and you should see generated files containing the `Impl` and `View` classes generated for your corresponding protobuf message definitions. 

## Motivation

This article assumes familiarity with protobuf and uses the following protobuf definitions which are adapted from the official protobuf documentation.

```protobuf
option java_package = "com.turbonomic.protoc.pojo.gen.addresses";
option java_outer_classname = "Addresses";

message Person {
  optional string name = 1;
  optional int32 id = 2;
  optional string email = 3;

  enum PhoneType {
    MOBILE = 0;
    HOME = 1;
    WORK = 2;
  }

  message PhoneNumber {
    optional string number = 1;
    optional PhoneType type = 2 [default = HOME];
  }

  repeated PhoneNumber phones = 4;
  
  map<string, Person> relations = 5;
}

message Business {
  optional string business_name = 1;
  optional string industry = 2;

  message Address {
    optional string street_address = 1;
    optional string city = 2;
    optional uint32 zip_code = 3;
  }

  optional Address location = 3;
}

message Entry {
  // We may enter a person or business in our address book.
  // The two entry types contain different information.
  oneof entry_type {
    Person person = 1;
    Business business = 2;
  }
}

message AddressBook {
  repeated Entry entries = 1;
}
```

### Why not just use protobuf builders?
Note that the below discussion of the shortcomings of protobuf builders for certain use cases applies only to protobuf builders generated for the **Java programming language** and may not apply to protobuf builders in other languages.

Protobuf builders provide a friendly API for building protobufs. They provide getters and setters for protobuf message internals. However, protobuf builders are not memory efficient under certain access patterns. Essentially, protobuf builders duplicate their internal message fields when accessing builders for those fields. Below is a high level sketch of how the internal memory layout of a protobuf message builder changes as it is accessed.

#### Single (Optional, Required, and OneOf) Fields

Consider the following Java code using the Java language bindings generated for the above protobuf definitions:

```java
final Business.Builder business = Business.newBuilder()
    .setLocation(Address.newBuilder().build());
```

This translates into a memory layout that looks something like the following (some details are left out for simplicity):

```text
business                       Business$Builder
 \__ location_                 Business$Address
```

Given the objects we have created, this seems like a reasonable set of objects to have in memory. Now consider what happens if we access the builder for the `location` field (even if we do not actually perform any changes) as below:

```java
final Business.Builder business = Business.newBuilder()
    .setLocation(Address.newBuilder().build());
    
// Access the location builder.
business.getLocationBuilder();
```

Since we have not explicitly modified any data, it seems reasonable to expect that the internal memory layout of the protobuf builders would remain the same, but in reality, we are now using more memory. The memory layout now looks like:

```text
business                       Business$Builder
 |__ location_                 null                     ---\  contents of location_
 \__ locationBuilder_          SingleFieldBuilderV3        |  moved to
      |__ builder_             Business$Address$Builder    |  locationBuilder_.message
      \__ message_             Business$Address         <--/
```

We now have both the builder and the built protobuf for the `location` field in memory at the same time, paying for it twice! Moreover, we now have an extra `SingleFieldBuilderV3` intermediary object to contain the message and the builder for the location field.

Note that even if we had modified the `Address.Builder`, it would lead to a memory layout containing both the built and `Builder` protobuf objects in memory at the same time. The above example is just used to illustrate that modification is not required to lead to memory duplication and extra allocations.

#### Repeated Fields

Protobuf builders will also duplicate data for internal repeated field messages. Consider the following code:

```java
final Person.Builder person = Person.newBuilder()
    .addPhones(PhoneNumber.newBuilder().setNumber("1"));
```

This translates into a memory layout that looks something like the following (some details are left out for simplicity):

```text
person                         Person$Builder
 \__ phones_                   ArrayList
     \__ elementData[0]        Person$PhoneNumber
```

Again, this seems like a reasonable set of objects to have in memory given the code. Now let’s see what happens if we access the builder for the PhoneNumber in our list of phones (even if we do not actually perform any changes) as in the following code:

```java
final Person.Builder person = Person.newBuilder()
    .addPhones(PhoneNumber.newBuilder().setNumber("1"));

// Access the builder for the phone number at element 0 without modifying it.
person.getPhonesBuilder(0);
```

This leads to the following memory layout where we again see that we are now retaining both a built `PhoneNumber` protobuf as well as a corresponding `PhoneNumber.Builder`.

```text
person                         Person$Builder
 |__ phones_                   null                    -----\ phones_ list is moved
 \__ phonesBuilder_            RepeatedFieldBuilderV3       | to the 
     |__ builders              ArrayList                    | RepeatedFieldBuilderV3
     |   \__ elementData[0]    SingleFieldBuilderV3         | messages field
     |        \__ builder      Person$PhoneNumber$Builder   |
     \__ messages              ArrayList              <-----/
         \__ elementData[0]    Person$PhoneNumber
```

We can see that in addition to the `SingleFieldBuilderV3` and the duplication of both the `PhoneNumber` and `PhoneNumber$Builder` objects analogous to the single field scenario above, we also have an extra `ArrayList` object allocation in the repeated field scenario. Note that iteration over a list of builders also produces duplication! For example, this code:

```java
final Person.Builder person = Person.newBuilder()
    .addAllPhones(IntStream.range(0, 100)
    .mapToObj(i -> PhoneNumber.getDefaultInstance())
    .collect(Collectors.toList()));

// Access the builder for the phone number at element 0 without modifying it.
final Optional<PhoneNumber.Builder> hasNumber = person.getPhonesBuilderList().stream()
    .filter(PhoneNumber.Builder::hasNumber)
    .findAny();
```

produces a memory layout that looks like:

```text
person                           Person$Builder
 \__ phonesBuilder_              RepeatedFieldBuilderV3
     |__ builders                ArrayList
     |   \__ elementData[0..99]  SingleFieldBuilderV3
     |        \__ builder        Person$PhoneNumber$Builder
     \__ messages                ArrayList
         \__ elementData[0..99]  Person$PhoneNumber
```

#### Nested Builders

We’ve now looked at `Builder`s that are direct children of a parent `Builder`. What about grandchildren? Or `Builder`s nested at an arbitrary depth? Is it possible that we could duplicate data more than once? The answer is yes. Consider the following code:

```java
final AddressBook.Builder book = AddressBook.newBuilder()
    .addEntries(Entry.newBuilder()
        .setBusiness(Business.newBuilder())); // Copy 1

book.getEntriesBuilder(0)
    .setBusiness(Business.newBuilder()); // Copy 2

book.getEntriesBuilder(0)
    .getBusinessBuilder(); // Copy 3
```

Given we are trying to represent one business in one entry in one book, intuitively we would expect to have one `Business` or `Business.Builder` in memory on execution of the above code, but in fact we have 2 `Business` objects and 1 `Business.Builder` object, as visualized in the memory layout below:

```text
book                                       AddressBook$Builder
 \__ entriesBuilder_                       RepeatedFieldBuilderV3
      |__ builders                         ArrayList
      |    \__ elementData[0]              SingleFieldBuilderV3
      |         \__ builder                Entry$Builder
      |             \__ businessBuilder_   SingleFieldBuilderV3
      |                  |__ builder       Business$Builder         <-- Copy 3
      |                  \__ message       Business                 <-- Copy 2
      \__ messages                         ArrayList
          \__ elementData[0]               Entry
               \__ entryType_              Business                 <-- Copy 1
```

While this example is somewhat contrived, it does serve to illustrate that as we nest messages deeper within other messages, it increases the number of objects we may create to represent the same data.

### Can We Avoid Duplication?

Unfortunately all methods I have discovered to eliminate the extra allocations come with significant downsides that make them unworkable for many purposes.

1. Modifying a field on a `Builder` retained by `SingleFieldBuilderv3` will drop the message reference in `SingleFieldBuilderv3`, but no memory is freed because the `Builder` object also has a reference (`BuilderParent`) which is not dropped!
2. Calling `myBuilder = myBuilder.clone()` on the top-level object will drop all internal builders.
   1. This is expensive (in CPU and GC churn)
   2. Probably not practical to do at the sort of scale at which the internal duplication becomes a problem.
3. On repeated fields, replace:
   1. calls like `person.getPhonesBuilder(0).setNumber("(123) 456-7890")`
   2. with calls like `person.setPhones(0, person.getPhones(0).toBuilder().setNumber("(123) 456-7890"))`
   3. But this is extremely awkward, particularly for repeated fields when you don’t actually know the index of the item you want to update, which requires first finding the index of the item before you can use it. This process requires extra boiler plate, offers more room for errors than approaches such as the enhanced for-loop, and requires vigilant enforcement via reviews because anyone can always resort to the memory-inefficient calls, undoing all the earlier work, without any errors or warnings from the compiler (and the code will also work).

### POJOs as an Alternative

As noted above, the protobuf builders are not designed to be memory efficient when their internal fields that have been set are repeatedly mutated over time. Rather than trying to awkwardly use protobuf builders for tasks for which they are ill-suited, we can continue to use a protobuf-based data model, but generate our own POJOs (plain old Java objects) that are crafted with a similar API to the familiar builders, stay in sync with protobuf definitions as they change, provide easy conversion back-and-forth between protobufs and POJOs, and do not use more than the expected amount of memory to represent the protobuf data model even as they are repeatedly mutated.

The protobuf compiler provides a plugin facility, allowing you to generate your own code from the protobuf definitions used to generate the normal protobuf language bindings. The `protoc-pojo-gen` project is a protobuf compiler plugin designed to generate POJOs that fit the above criteria.

### How Much Memory Does this Save in Practice?

In a real-world application that makes many modifications to protobuf builders over the course of a series of operations, replacing the POJOs with protobufs reduced memory usage for the relevant data from 4.1 GB to 2.0 GB, an approximately 51.2% savings. The runtime of the operations performing the transformation remained essentially the same even after accounting for time spent transforming data back and forth between protobuf and POJO format.

## Comparing official Java generated language bindings with protoc-pojo-gen POJOs

The `protoc-pojo-gen` plugin creates two kinds of objects for a protobuf message, a read-only `View` interface and a mutable `Impl` implementation of the interface. Let's see how these compare to the built protobuf and `Builder` respectively.

The official Java protobuf bindings generate two kinds of objects for each protobuf definition:

1. Built protobufs:
   1. Examples in this category from our example protobuf definitions include `AddressBook`, `Address`, `Person`, and `Business`.
   2. Built protobufs are immutable and be used to generate an array of bytes in the protobuf serialization format to be sent over the wire.
   3. Built protobufs are generated by calling the `#build()` method on their matching `Builder` object.
2. Protobuf builders:
   1. Examples in this category from our example protobuf definitions include `AddressBook.Builder`, `Address.Builder`, `Person.Builder`, and `Business.Builder`.
   2. Protobuf builders are mutable and can be used to generate their matching built protobufs via their `#build()` method.
   3. Protobuf builders are created by calling the `#newBuilder()` static factory method.
      
The generated POJOs provide similar functionality:

1. The `View` interfaces:
   1. Examples of `View` POJOs matching built protos from our example above include `AddressBookView`, `AddressView`, `PersonView`, and `BusinessView`.
   2. The `View` interface provides unmodifiable access to an underlying modifiable `Impl` (discussed below) instance capable of representing the same data as the protobuf whose definitions it is generated from.
   3. Because each `View` interface instance shares an *“is-a”* relationship with its underlying `Impl` implementation, we do not need to create any new objects to get a `View` from an `Impl`, a simple assignment will suffice as in: `AddressView addressView = new AddressImpl()`.
2. The `Impl` classes:
   1. Examples of `Impl` POJOs matching `Builder` protos from our example above include `AddressBookImpl`, `AddressImpl`, `PersonImpl`, and `BusinessImpl`.
   2. The `Impl` interface provides mutable access to a data structure capable of representing the same information as the proto `Builder` whose definition it is generated from.
   3. To create a new `Impl` instance, simply call its constructor as in: `new AddressImpl()`. Do not cast `View` references back to their `Impl` type, because receiving a `View` POJO generally indicates that the owner of the `Impl` does not expect its POJO to be modified.

## The POJO APIs

The interface for the generated POJOs are designed to be similar and familiar to the interfaces for the equivalent protobuf builders. Here are some comparisons for common operations on a builder and the equivalent operations on a POJO.

### Packages, Interfaces, and Classes:

#### Packages and Files:

Packages are created according to the `java_package` specified in the protobuf definitions supplied to the `protoc-pojo-gen` code generator. One Java file is created per protobuf definition file, with the file named according to the `java_outer_classname` in the protobf definitions, with the `POJO` ffix appended. For example, in our addresses example, the generated POJOs are written to a file named `AddressesPojo.java`.

All generated classes and interfaces are defined as static inner classes on an outer class named according to the `java_outer_classname` in the protobuf definition file.

#### Interfaces:

he POJO generator defines an interface `IntoProto<T extends AbstractMessage, B extends AbstractMessage.Builder<B>> extends Serializable` that all generated POJOs will extend. This allows client code to generically take any POJO that can be translated into a specific protobuf and its builder.

The POJO generator also generates one `View` interface for each message definition in the original protobuf definitions. For example, in our addresses example, we generate the following `View` interfaces:

```java
public interface PersonView extends IntoProto<Person, Person.Builder>
public interface PhoneNumberView extends IntoProto<PhoneNumber, PhoneNumber.Builder>
public interface BusinessView extends IntoProto<Business, Business.Builder>
public interface AddressView extends IntoProto<Address, Address.Builder>
public interface EntryView extends IntoProto<Entry, Entry.Builder>
public interface AddressBookView extends IntoProto<AddressBook, AddressBook.Builder>
```

As explained above, `View` interfaces provide read-only access to their related `Impl` implementations. `View`s provide methods for the following functionality:

1. Getters: ie `personView.getId()` or `personView.getPhonesCount()` or `businessView.getAddress()`
2. Note that while `View`s provide getters for the read-only `View`s for their internal message fields, they do not provide getters to the mutable `Impl`s for internal message fields
3. Hazzers: ie `personView.hasId()`
4. Static method for accessing a default instance: ie `PersonView.getDefaultInstance()`
5. Conversion to proto: ie `personView.toProto()`

#### Classes:

For POJO generator defines one class implementation for each message definition in the original protobuf definitions. For example, in our addresses example, we generate the following `Impl` classes:

```java
public static class PersonImpl implements PersonView
public static class PhoneNumberImpl implements PhoneNumberView
public static class BusinessImpl implements BusinessView
public static class AddressImpl implements AddressView
public static class EntryImpl implements EntryView
public static class AddressBookImpl implements AddressBookView
```

As explained above, `Impl` classes provide getter and setter access to the message that they represent. This means that they implement the functionality exposed by their `View` interfaces

1. Getters: ie `personImpl.getId()` or `personImpl.getPhonesCount()`, `businessView.getAddress()`, or `businessView.getOrCreateAddress()`.
   1. Note that while `Impl`s provide getters for both the read-only `View`s for their internal message fields as well as getters to the mutable `Impl`s for internal message fields. The `#getOrCreate` methods will return `Impl` instances.
2. Hazzers: ie `personImpl.hasId()`
3. Static method for accessing a default instance: ie `personImpl.getDefaultInstance()`
4. Conversion to proto: ie `personImpl.toProto()`

as well as providing access to:

1. Setters and clear methods: ie `personImpl.setId(id)` and `personImpl.clearId()`
2. Static method for converting from a proto: ie `PersonImpl.fromProto(personProto)`
3. Constructors:
   1. A default empty constructor ie `new PersonImpl()`
   2. A copy constructor ie `new PersonImpl(otherPersonImpl)`

### optional and required fields:

#### message fields:

```java
final BusinessView newYork = new BusinessImpl()
    .setLocation(new Address().setCity("New York"));
final BusinessImpl chicago = new BusinessImpl();
chicago.getOrCreateLocation().setCity("Chicago");

// Access to read-only views of internal messages
assertEquals("New York", newYork.getLocation().getCity());
assertEquals(new Address().setCity("Chicago"), chicago.getLocation());

// Access to mutable Impls of internal messages. Move Chicago to Cleveland
chicago.getOrCreateLocation().setCity("Cleveland")
assertEquals("Cleveland", chicago.getLocation().getCity());
```

#### non-message fields:

```java
final PersonImpl person = new PersonImpl()
    .setId(1)
    .setEmail("person@email.com");

assertFalse(person.hasName());
assertTrue(person.hasId());
assertEquals(1, person.getId());

person.clearId();
assertFalse(person.hasId());
```

### oneof fields:

Note that generated POJOs directly reuse the oneOf case enums defined by the protobuf generation rather than redefining an identical case enum.

```java
final EntryImpl entry = new EntryImpl();

assertFalse(entry.hasPerson());
assertFalse(entry.hasBusiness());
assertEquals(ENTRYTYPE_NOT_SET, entry.getEntryTypeCase());

entry.setPerson(PersonView.getDefaultInstance());
assertTrue(entry.hasPerson());
assertFalse(entry.hasBusiness());
assertEquals(PERSON, entry.getEntryTypeCase());
assertEquals(PersonView.getDefaultInstance(), entry.getPerson());

entry.getOrCreateBusiness().setBusinessName("Cupcake Factory");
assertFalse(entry.hasPerson());
assertTrue(entry.hasBusiness());
assertEquals(BUSINESS, entry.getEntryTypeCase());
assertEquals(new BusinessImpl().setBusinessName("Cupcake Factory"), entry.getBusiness());

entry.clearBusiness();
assertEquals(ENTRYTYPE_NOT_SET, entry.getEntryTypeCase());
```

### Repeated fields

```java
final PersonImpl person = new PersonImpl()
    .addPhones(new PhoneNumberImpl().setNumber("(123) 456-7890").setType(PhoneType.HOME))
    .addPhones(new PhoneNumberImpl().setNumber("(777) 777-7777").setType(PhoneType.MOBILE))
    .addPhones(new PhoneNumberImpl().setNumber("(888) 888-8888").setType(PhoneType.WORK));

final List<PhoneNumberView> phones = person.getPhonesList();
assertEquals("(888) 888-8888", phones.get(2).getNumber());
assertEquals(3, person.getPhonesCount());

person.getPhonesImpl(1).setNumber("(111) 111-1111");
assertEquals("(111) 111-1111", phones.get(1).getNumber());

person.setPhones(1, new PhoneNumberImpl().setNumber("(222) 222-2222"));
assertEquals("(222) 222-2222", phones.get(1).getNumber());

person.removePhones(1);
assertEquals(2, person.getPhonesCount());

// Duplicate all the phones on the person
person.addAllPhones(person.copy().getPhonesList());
assertEquals(4, person.getPhonesCount());
```

### Map fields

```java
final PersonImpl alice = new PersonImpl().setName("alice");
final PersonView bob = new PersonImpl().setName("bob");
final PersonView carol = new PersonImpl().setName("carol");
final PersonView dan = new PersonImpl().setName("dan");

alice.putRelations("husband", bob);
alice.putAllRelations(ImmutableMap.of(
    "bestie", carol,
    "uncle", dan,
    "professor", new PersonImpl().setName("edna")));
assertEquals(4, alice.getRelationsCount());

assertEquals("dan", alice.getRelationsOrThrow("uncle").getName());

alice.getRelationsImplOrThrow("bestie").setEmail("carol@email.com");
alice.removeRelations("professor");
assertEquals(3, alice.getRelationsCount());
   
assertTrue(alice.getRelationsMap().containsKey("husband"));
```

### Miscellaneous Behavior:

#### Default Instances:

To obtain a default instance for a POJO, use the `#getDefaultInstance()` static method defined on the `View` interface. The same default instance is always returned and should never be modified. No access is provided to the `Impl` for the default instance which prevents it from being modified except through casting or reflection, which should not be done.

```java
final AddressView address = AddressView.getDefaultInstance()
```

#### Field Defaults:

POJOs support default values of fields. When protobuf definitions do not specify a specific default value for a field, the POJOs use the same default as described by the protobuf specifications in the absence of a default (ie 0 for an int, empty string for strings, false for booleans, etc.)

If a protobuf field definition does specify a default, the POJOs will respect that default. In our example protobuf definitions include a default for the `PhoneNumber.type` field as in

```java
optional PhoneType type = 2 [default = HOME];
```

and so if we create a `new PhoneNumberImpl()` and check its `type` without first setting it, we can see that it is indeed the default of `HOME` whereas if no default had been specified by the definitions, it would have been `MOBILE` since it appears first in the enum definition.

```java
assertEquals(PhoneType.HOME, new PhoneNumberImpl().getType());
```

#### Enums

The POJO compiler plugin does not generate any new `Enum`s to represent the protobuf enums. Rather, `protoc-pojo-gen` reuses the Enums generated for the standard Java protobuf language bindings. This is because the standard generated protobuf `Enum`s are already memory efficient, and there would be no advantage to redefining the exact same enumerations. Reusing the proto generated enums also allows easy comparison between the enums on POJO instances and those on proto instances.

### Convenience Methods:

In addition to offering the getters and setters for fields offered by protobuf builders, the generated POJOs offer various convenience methods.

#### Conversions:

Protobufs and POJOs can easily be converted back and forth from one to the other.

* toProto and toProtoBuilder:

```java
final Person pojo = new Person().setId(1).setEmail("person@email.com");
assertEquals(
    AddressBookDTO.Person.newBuilder()
        .setId(1)
        .setEmail("person@email.com")
        .build(),    
    pojo.toProto());
```

* fromProto: POJOs can be converted from the equivalent built protobuf or builder.

```java
final AddressBookDTO.Person.Builder builder = AddressBookDTO.Person.newBuilder()
    .setId(1)
    .setEmail("person@email.com");

assertEquals(Person.fromProto(builder), Person.fromProto(builder.build()));
```

* toByteArray

```java
final AddressBookDTO.Person proto = AddressBookDTO.Person.newBuilder()
    .setId(1)
    .setEmail("person@email.com")
    .build();
final PersonView pojo = new PersonImpl().setId(1).setEmail("person@email.com");

assertArrayEquals(proto.toByteArray(), pojo.toByteArray());
```

#### Comparison:

A common use case with protobufs and generated POJOs when using them in situations where they are frequently transformed is in unit tests to verify the transformations applied to POJOs is correct. To facilitate this we implement equals and hashCode so that POJOs can easily be compared to each other.

:warning: Do not use POJOs that may be mutated as keys in a map or elements of sets. This can lead to incorrect and unexpected behavior if the POJOs are mutated.

* hashCode

```java
final PersonView person1 = new PersonImpl().setId(1).setEmail("person1@email.com");
final PersonView person2 = new PersonImpl().setId(2).setEmail("person2@email.com");
final PersonView identicalToPerson1 = new PersonImpl().setId(1).setEmail("person1@email.com");

assertNotEquals(person1.hashCode(), person2.hashCode()); // Note that this is not guaranteed in the case of a hash collision, but it is unlikely
assertEquals(person1.hashCode(), identicalToPerson1.hashCode());
```

* equals

```java
final PersonView person1 = new PersonImpl().setId(1).setEmail("person1@email.com");
final PersonView person2 = new PersonImpl().setId(2).setEmail("person2@email.com");
final PersonView identicalToPerson1 = new PersonImpl().setId(1).setEmail("person1@email.com");

assertNotEquals(person1, person2);
assertEquals(person1, identicalToPerson1);
```

#### Copying:

* Copy: Copy the pojo to a new pojo that is equivalent.

```java
final PersonView person = new PersonImpl().setId(2).setEmail("person@email.com");
final PersonView copy = person.copy();

assertEquals(2, copy.getId());
assertEquals("person@email.com", copy.getEmail());
assertEquals(person, copy);
assertEquals(person.hashCode(), copy.hashCode());
```

* copy constructor: Copy a pojo via its constructor.

```java
final PersonView person = new PersonImpl().setId(2).setEmail("person@email.com");
final PersonView copy = new PersonImpl(person);

assertEquals(2, copy.getId());
assertEquals("person@email.com", copy.getEmail());
assertEquals(person, copy);
assertEquals(person.hashCode(), copy.hashCode());
```

### Non-Uses

1. Since the POJOs are mutable, do not use POJOs as keys in `Map`s or as members of `Set`s if those POJOs may change.
   1. Mutating a POJO changes its `hashCode`. To see why this is dangerous, refer to the answer in  https://stackoverflow.com/questions/7842049/are-mutable-hashmap-keys-a-dangerous-practice.
   2. Note that even when you can guarantee that your POJOs will never change, it may still be unwise to put use them as a key in a Map or put them in a Set because computing their hashCodes and comparing equality can be extremely performance intensive for deeply nested POJOs (or even shallow POJOs with many repeated fields).
   3. An exception to this rule is if using something like an IdentityHashMap.

### Features available on protobufs but not on POJOs

Generated Java protobufs contain a powerful custom reflection API for introspection of protobufs in Java. The generated POJOs have no equivalent introspection functionality.

## Important Differences from Protobufs

### In Protobuf, Message and Message.Builder are two different objects

Consider the following Java code using the official protobuf generated language bindings:

```java
Person.Builder builder = Person.newBuilder().setId(2);
Person built = builder.build();

assertNotEquals(builder, built);
assertNotSame(builder, built);
```

In protobuf, the builder and built protobufs are *different* objects. They share a common interface, but they will never be equal. In contrast, consider the very similar POJO code:

```java
PersonImpl impl = new PersonImpl().setInt(2);
PersonView view = impl;

assertEquals(impl, view);
assertSame(impl, view);
```

The POJO implementation and view for the message are actually the same! We can compare them to each other for equality, and the comparison may succeed if they equivalent in content.

### Protubufs and POJOs copy data slightly differently

Consider the following Java code using the official protobuf generated language bindings:

```java
// Create an initial phone number
PhoneNumber.Builder phone = PhoneNumber.newBuilder()
    .setNumber("(123) 456-7890")
    .setType(PhoneType.WORK);

// Set the phone number on the person
Person.Builder person = Person.newBuilder()
    .addPhones(phone)

// Change the initial phone number
phone.setNumber("(888) 888-8888")

// The number set on the person does not change
assertEquals("(888) 888-8888", phone.getNumber());
assertEquals("(123) 456-7890", person.getPhones(0).getNumber());
```

In contrast, in the equivalent POJO code, the number on the person does change.

```java
// Create an initial phone number
PhoneNumberImpl phone = new PhoneNumberImpl()
    .setNumber("(123) 456-7890")
    .setType(PhoneType.WORK);

// Set the phone number on the person
PersonImpl person = new PersonImpl()
    .addPhones(phone)

// Change the initial phone number
phone.setNumber("(888) 888-8888")

// The number set on the person does not change
assertEquals("(888) 888-8888", phone.getNumber());
assertEquals("(888) 888-8888", person.getPhones(0).getNumber());
```

This is because in the protobuf code, protos, always retain a copy of the builder passed in rather than the original builder when setting an internal message field. That is, when we call `#addPhones` on the `Person.Builder`, we don’t actually retain a reference to the `PhoneNumber.Builder` we pass in. Instead, the protobuf code will call build on the `PhoneNumber.Builder` and keep the built protobuf.

POJOs, on the other hand, may retain the original passed in `Impl` and avoid the copy when they deem it safe to do so. How can a POJO know whether it is safe to retain an original, or whether it needs to make a copy? To make this decision, POJOs dedicate a bit in a bit field that is initial 0, and when it is assigned a parent, the bit is set to 1. Thus, the first time a POJO is assigned to a parent, we avoid the copy. Based on an analysis of usage of Java protobufs, the same proto builder is almost never assigned to multiple parents, so this single bit allows us to avoid a copy in almost all cases. Because protos (and therefore POJOs) can be deeply nested, copies can be fairly expensive and unnecessary copies can create lots of extra garbage that the garbage collector then has to process. We do not attempt to clear this bit when a message is removed from its parent because doing so and removing a message from its parent and then reusing it is a very uncommon access pattern.

In most common access patterns observed so far, this difference in behavior may affect code like unit tests but tends not to be much of a factor in production code.

#### Why do protobufs and POJOs need to copy data at all?

If it’s safe to avoid a copy when assigning a POJO to its first parent, why bother copying at all? Why not avoid all copies? The answer is that allowing a POJO to have multiple parents could lead to extremely unexpected behavior.

Consider the following POJO code:

```java
PhoneNumberImpl phone = new PhoneNumberImpl()
    .setNumber("(123) 456-7890")
    .setType(PhoneType.WORK);

// Set the phone number on the person
PersonImpl person1 = new PersonImpl()
    .addPhones(phone)
PersonImpl person2 = new PersonImpl()
    .addPhones(phone)
    
...
// now a lot of stuff happens, a long time passes, and we forget that 
// person1 and person2 are sharing the same phone number
...

// In some other place in the code completely unassociated with the
// code above where it is very hard to tell that a phone number may be shared
person1.getPhonesImpl(0).setNumber("(888) 888-8888")
```

If we allowed the same `PhoneNumberImpl` object to be referenced by both `person1` and `person2`, then the last line that modifies `person1`'s `PhoneNumber` will change `person2`'s `PhoneNumber`. However, in both protos and POJOs, because we prevent internal message reference sharing (via the copying mechanism), we can guarantee that changing one message’s internal messages can never change the internals of another message.
